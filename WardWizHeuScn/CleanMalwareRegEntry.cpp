
#include "StdAfx.h"
#include "CleanMalwareRegEntry.h"
#include <Shlwapi.h>
#include <tchar.h>


CCleanMalwareRegEntry::CCleanMalwareRegEntry()
{
	ZeroMemory(szPath, sizeof(szPath));
}

CCleanMalwareRegEntry::~CCleanMalwareRegEntry()
{

}

/**********************************************************************************************************
*  Function Name  :	RegDelnodeRecurse
*  Description    : delete invalid key
*  Author Name    : pradip
*  Date           : 28-10-2018
**********************************************************************************************************/
BOOL CCleanMalwareRegEntry::RegDelnodeRecurse(HKEY hKeyRoot, LPTSTR lpSubKey)
{
	LPTSTR		lpEnd;
	LONG		lResult;
	DWORD		dwSize;
	TCHAR		szName[MAX_PATH] = { 0 };
	HKEY		hKey = NULL;
	FILETIME	ftWrite;

	// First, see if we can delete the key without having
	// to recurse.

	__try
	{

		lResult = RegDeleteKey(hKeyRoot, lpSubKey);

		if (lResult == ERROR_SUCCESS)
			return TRUE;

		lResult = RegOpenKeyEx(hKeyRoot, lpSubKey, 0, KEY_READ, &hKey);

		if (lResult != ERROR_SUCCESS)
		{
			if (lResult == ERROR_FILE_NOT_FOUND)
			{
				//printf("Key not found.\n");
				return TRUE;
			}
			else
			{
				//printf("Error opening key.\n");
				return FALSE;
			}
		}

		// Check for an ending slash and add one if it is missing.

		lpEnd = lpSubKey + lstrlen(lpSubKey);

		if (*(lpEnd - 1) != TEXT('\\'))
		{
			*lpEnd = TEXT('\\');
			lpEnd++;
			*lpEnd = TEXT('\0');
		}

		// Enumerate the keys

		dwSize = MAX_PATH;
		lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
			NULL, NULL, &ftWrite);

		if (lResult == ERROR_SUCCESS)
		{
			do
			{

				lstrcpy(lpEnd, szName);
				if (!RegDelnodeRecurse(hKeyRoot, lpSubKey))
				{
					break;
				}

				dwSize = MAX_PATH;

				lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
					NULL, NULL, &ftWrite);

			} while (lResult == ERROR_SUCCESS);
		}

		lpEnd--;
		*lpEnd = TEXT('\0');

		RegCloseKey(hKey);
		hKey = NULL;

		// Try again to delete the key.

		lResult = RegDeleteKey(hKeyRoot, lpSubKey);

		if (lResult == ERROR_SUCCESS)
			return TRUE;

	}
	__except (CWardWizDumpCreater::CreateMiniDump(GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER)
	{
		AddLogEntry(L"### Exception in WardwizSrvMgmt_RegOpt::RegDelnodeRecurse", 0, 0, true, SECONDLEVEL);
	}

	return FALSE;
}

/**********************************************************************************************************
*  Function Name  :	DeleteInvalidKey
*  Description    :Delete invalid key in registry
*  Author Name    : Pradip
*  Date           : 29-10-2018
**********************************************************************************************************/
BOOL CCleanMalwareRegEntry::DeleteInvalidKey(HKEY hKeyRoot, LPTSTR lpSubKey)
{

	__try
	{

		TCHAR	szDelKey[2048] = { 0 };

		lstrcpy(szDelKey, lpSubKey);
		if (RegDelnodeRecurse(hKeyRoot, szDelKey))
			return TRUE;

		Sleep(10);
		ZeroMemory(szDelKey, sizeof(szDelKey));
		lstrcpy(szDelKey, lpSubKey);
		if (RegDelnodeRecurse(hKeyRoot, szDelKey))
			return TRUE;

		Sleep(100);
		ZeroMemory(szDelKey, sizeof(szDelKey));
		lstrcpy(szDelKey, lpSubKey);
		if (RegDelnodeRecurse(hKeyRoot, szDelKey))
			return TRUE;

	}
	__except (CWardWizDumpCreater::CreateMiniDump(GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER)
	{
		AddLogEntry(L"### Exception in WardwizSrvMgmt_RegOpt::DeleteInvalidKey", 0, 0, true, SECONDLEVEL);
	}

	return FALSE;
}

/**********************************************************************************************************
*  Function Name  :	SetRegSZValue
*  Description    :Set registry value data
*  Author Name    :Pradip
*  Date           :29-10-2018
**********************************************************************************************************/
DWORD CCleanMalwareRegEntry::SetRegSZValue(TCHAR *pSubKey, TCHAR *pValueName, TCHAR *pValueData, bool bCheck, HKEY hPredKey)
{
	DWORD	dwRet = 0x00;
	HKEY	hSubKey = NULL;

	__try
	{

		TCHAR	szValueData[512] = { 0 };
		DWORD	dwSize = 512, dwType = 0x00;

		if (RegOpenKeyEx(hPredKey, pSubKey, 0, KEY_ALL_ACCESS, &hSubKey) != ERROR_SUCCESS)
		{
			dwRet = 0x01;
			goto Cleanup;
		}

		RegQueryValueEx(hSubKey, pValueName, 0, &dwType, (LPBYTE)szValueData, &dwSize);
		dwSize = static_cast<DWORD>(wcslen(pValueData)*sizeof(TCHAR)+2);
		if (bCheck)
		{
			if (_wcsicmp(szValueData, pValueData) != 0)
				dwRet = RegSetValueEx(hSubKey, pValueName, 0, dwType, (LPBYTE)pValueData, dwSize);
			else
				dwRet = 0x02;
		}
		else
			dwRet = RegSetValueEx(hSubKey, pValueName, 0, dwType, (LPBYTE)pValueData, dwSize);

	}
	__except (CWardWizDumpCreater::CreateMiniDump(GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER)
	{
		dwRet = 0x03;
		AddLogEntry(L"### Exception in WardwizSrvMgmt_RegOpt::SetRegSZValue", 0, 0, true, SECONDLEVEL);
	}

Cleanup:

	if (hSubKey)
		RegCloseKey(hSubKey);

	hSubKey = NULL;

	return dwRet;
}



/**********************************************************************************************************
*  Function Name  :	SetRegDWORDValue
*  Description    :set Dword value in registry
*  Author Name    :Pradip
*  Date           :30-10-2018
**********************************************************************************************************/
DWORD CCleanMalwareRegEntry::SetRegDWORDValue(TCHAR *pSubKey, TCHAR *pValueName, DWORD dwSetValueData, bool bCheck, HKEY hPredKey)
{
	DWORD	dwRet = 0x00;
	HKEY	hSubKey = NULL;

	__try
	{

		DWORD	dwValueData = 0x00;
		DWORD	dwSize = 0x00, dwType = 0x00;

		if (RegOpenKeyEx(hPredKey, pSubKey, 0, KEY_ALL_ACCESS, &hSubKey) != ERROR_SUCCESS)
		{
			dwRet = 0x01;
			goto Cleanup;
		}

		dwSize = sizeof(DWORD);
		RegQueryValueEx(hSubKey, pValueName, 0, &dwType, (LPBYTE)dwValueData, &dwSize);

		dwSize = sizeof(DWORD);
		if (bCheck)
		{
			if (dwSetValueData != dwValueData)
				dwRet = RegSetValueEx(hSubKey, pValueName, 0, dwType, (LPBYTE)&dwSetValueData, dwSize);
			else
				dwRet = 0x02;
		}
		else
			dwRet = RegSetValueEx(hSubKey, pValueName, 0, dwType, (LPBYTE)&dwSetValueData, dwSize);

	}
	__except (CWardWizDumpCreater::CreateMiniDump(GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER)
	{
		dwRet = 0x03;
		AddLogEntry(L"### Exception in WardwizSrvMgmt_RegOpt::SetRegDWORDValue", 0, 0, true, SECONDLEVEL);
	}

Cleanup:

	if (hSubKey)
		RegCloseKey(hSubKey);

	hSubKey = NULL;

	return dwRet;
}

/**********************************************************************************************************
*  Function Name  :	CheckForPathExist
*  Description    :
*  Author Name    : pradip
*  Date           : 30-10-2018
**********************************************************************************************************/
TCHAR* CCleanMalwareRegEntry::CheckForPathExist(TCHAR *pPath)
{
	
	__try
	{
		TCHAR	*pTemp = NULL;
		

		if (pPath[0] == '"')
			wcscpy_s(szPath, 511, &pPath[1]);
		else
			wcscpy_s(szPath, 511, pPath);
		_wcsupr_s(szPath, 511);

		pTemp = wcsstr(szPath, TEXT(".EXE"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT(".EXE"));
			*pTemp = '\0';
		}

		pTemp = wcsstr(szPath, TEXT(".SYS"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT(".SYS"));
			*pTemp = '\0';
		}

		pTemp = wcsstr(szPath, TEXT(".DLL"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT(".DLL"));
			*pTemp = '\0';
		}

		pTemp = wcsstr(szPath, TEXT(".OCX"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT(".OCX"));
			*pTemp = '\0';
	     }

		if (PathFileExists(szPath))
			
               //wcscpy_s(szPathName, 512, szPath);
			return szPath;

	}
	__except (CWardWizDumpCreater::CreateMiniDump(GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER)
	{
		AddLogEntry(L"### Exception in WardwizSrvMgmt_RegOpt::CheckForPathExist", 0, 0, true, SECONDLEVEL);
		return 0;
	}	
	return szPath;
}

/**********************************************************************************************************
*  Function Name  :	EnumRegValueDataDeletion
*  Description    :Check value data from registry if found invalid then delete it
*  Author Name    : Pradip
*  Date           :30-10-2018
**********************************************************************************************************/
DWORD CCleanMalwareRegEntry::EnumRegValueDataDeletion(LPCTSTR pSubKey, TCHAR *pValueData, HKEY hPredKey)
{

	DWORD	dwRet = 0x00;
	DWORD	dwValues, dwType = 0x00, i;
	HKEY	hSubKey=NULL ;
	TCHAR   *szPathName = NULL;
	TCHAR	szValueName[512], szValueData[512];
	DWORD	dwValueName, dwValueData,dwSubKeys=0x00;
	TCHAR   *szValuDataN = NULL;
	
	_try
	{

		if (RegOpenKeyEx(hPredKey, pSubKey, 0, KEY_ALL_ACCESS, &hSubKey) != ERROR_SUCCESS)
		{
			dwRet = 0x01;
			goto Cleanup;

		}

		bool	bRegInvalidFound = false;


		while (true)
		{
			bRegInvalidFound = false;
			dwValues = 0x00;
			
			RegQueryInfoKey(hSubKey, NULL, NULL, 0, &dwSubKeys, NULL, NULL, &dwValues, NULL, NULL, NULL, NULL);
			if (dwValues == 0x00)
			{
				dwRet = 0x02;
				break;

			}
			if (dwSubKeys)
			{
				for (i = 0; i < dwSubKeys; i++)
				{

				}
			}
			 
			for (i = 0; i < dwValues; i++)
			{
				memset(szValueName, 0x00, 512 * sizeof(TCHAR));
				memset(szValueData, 0x00, 512 * sizeof(TCHAR));

				dwValueName = dwValueData = 511;

				RegEnumValue(hSubKey, i, szValueName, &dwValueName, 0, &dwType, (LPBYTE)szValueData, &dwValueData);
				if (!szValueName[0])
					continue;

				szPathName = CheckForPathExist(szValueData);
				szValuDataN = MyToUpper(pValueData);

				if (!_tcscmp(szPathName, szValuDataN))
				{
					if (RegDeleteValue(hSubKey, szValueName) == ERROR_SUCCESS)
					{
						bRegInvalidFound = true;
						
						//printf("deleted valuename");

					}
				}

				if (bRegInvalidFound)
					break;
			}

			if (!bRegInvalidFound)
				break;
		}
	}
	__except (CWardWizDumpCreater::CreateMiniDump(GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER)
	{
		AddLogEntry(L"### Exception in WardwizSrvMgmt_RegOpt::EnumRegValueDataDeletion", 0, 0, true, SECONDLEVEL);
		dwRet = 0x03;
	}
Cleanup:

	if (hSubKey)
		RegCloseKey(hSubKey);

	hSubKey = NULL;
	ZeroMemory(szPath, sizeof(szPath));
	return dwRet;
}

/**********************************************************************************************************
*  Function Name  :	EnumRegValueDataForCurrentUsers
*  Description    :Check value data from registry for current user if found invalid then delete it
*  Author Name    : Pradip
*  Date           :30-10-2018
**********************************************************************************************************/
DWORD CCleanMalwareRegEntry::EnumRegValueDataForCurrentUsers(LPTSTR lpszSubKey, TCHAR *pValueData)
{
	DWORD	dwRet = 0x00;
	HKEY	hCurrentUserKey = NULL;
	HKEY	hSubKey = NULL;

	__try
	{

		RegConnectRegistry(NULL, HKEY_USERS, &hCurrentUserKey);

		DWORD	dwSubKeys = 0x00, i = 0x00;

		if (RegQueryInfoKey(hCurrentUserKey, NULL, NULL, 0, &dwSubKeys, NULL, NULL, NULL, NULL,NULL, NULL, NULL) != ERROR_SUCCESS)
		{
			dwRet = 0x02;
			goto Cleanup;
		}

	
		for (; i < dwSubKeys; i++)
		{
			DWORD	dwType = 0x00;
			DWORD	dwSize = 511;

			TCHAR	szCurrSubKeyName[512] = { 0 };
			TCHAR	szSubKeyName[512] = { 0 };

			RegEnumKeyEx(hCurrentUserKey, i, szCurrSubKeyName, &dwSize, 0, NULL, NULL, NULL);
			if ((wcslen(szCurrSubKeyName) <0x09) || (wcsstr(szCurrSubKeyName, L"_Classes")))
				continue;

			if (wmemcmp(szCurrSubKeyName, L"S-", wcslen(L"S-")) != 0x00)
				continue;

			wsprintf(szSubKeyName, TEXT("%s\\%s"), szCurrSubKeyName, lpszSubKey);

			RegOpenKeyEx(hCurrentUserKey, szSubKeyName, 0, KEY_ALL_ACCESS, &hSubKey);

			
			if (hSubKey)
			{
				EnumRegValueDataDeletionForCurrentUsers(hSubKey, lpszSubKey,pValueData, HKEY_CURRENT_USER);

				RegCloseKey(hSubKey);
				hSubKey = NULL;
			}
		}

	}
	__except (CWardWizDumpCreater::CreateMiniDump(GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER)
	{
		dwRet = 0x10;
		AddLogEntry(L"### Exception in CCleanMalwareRegEntry::EnumRegValueDataDeletionForCurrentUser", 0, 0, true, SECONDLEVEL);
	}

Cleanup:


	if (hSubKey)
	{
		RegCloseKey(hSubKey);
		hSubKey = NULL;
	}

	if (hCurrentUserKey)
	{
		RegCloseKey(hCurrentUserKey);
		hCurrentUserKey = NULL;
	}

	return dwRet;
}

/**********************************************************************************************************
*  Function Name  :	EnumRegValueDataDeletionForCurrentUsers
*  Description    :Check value data from registry for current user if found invalid then delete it
*  Author Name    : Pradip
*  Date           :31-10-2018
**********************************************************************************************************/
DWORD CCleanMalwareRegEntry::EnumRegValueDataDeletionForCurrentUsers(HKEY hSubKey, TCHAR *pSubKey, TCHAR *pValueData, HKEY hPredKey)
{

	DWORD	dwRet = 0x00;
	DWORD	dwValues = 0x00, dwType = 0x00, i;

	TCHAR	szValueName[512], szValueData[512];
	DWORD	dwValueName, dwValueData;
	TCHAR   *szPathName = NULL;
	TCHAR   *szValueDataU = NULL;
	
	__try
	{

		if (!hSubKey)
		{
			dwRet = 0x01;
			goto Cleanup;
		}

		bool	bRegInvalidFound = false;
		
		while (true)
		{
			bRegInvalidFound = false;
			dwValues = 0x00;
			RegQueryInfoKey(hSubKey, NULL, NULL, 0, NULL, NULL, NULL, &dwValues, NULL,
				NULL, NULL, NULL);
			if (dwValues == 0x00)
			{
				dwRet = 0x02;
				break;
			}

			for (i = 0; i<dwValues; i++)
			{
				memset(szValueName, 0x00, 512 * sizeof(TCHAR));
				memset(szValueData, 0x00, 512 * sizeof(TCHAR));
				
				dwValueName = dwValueData = 511;

				RegEnumValue(hSubKey, i, szValueName, &dwValueName, 0, &dwType,(LPBYTE)szValueData, &dwValueData);
				if (!szValueName[0])
					continue;

				szPathName = CheckForPathExist(szValueData);
				szValueDataU = MyToUpper(pValueData);

				if (!_tcscmp(szPathName, szValueDataU))
				{
					if (RegDeleteValue(hSubKey, szValueName) == ERROR_SUCCESS)
					{
						bRegInvalidFound = true;

						//printf("deleted valuename");

					}
				}
				if (bRegInvalidFound)
					break;
			}

			if (!bRegInvalidFound)
				break;
		}
	}
	__except (CWardWizDumpCreater::CreateMiniDump(GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER)
	{
		dwRet = 0x10;
		AddLogEntry(L"### Exception in CCleanMalwareRegEntry::EnumRegValueDataForCurrentUsers", 0, 0, true, SECONDLEVEL);
	}

Cleanup:

	return dwRet;
}

/**********************************************************************************************************
*  Function Name  :	CheckServiceValidPath
*  Description    :
*  Author Name    : Vilas & Prajakta
*  Date           : 16 Nov 2013
**********************************************************************************************************/

DWORD CCleanMalwareRegEntry::CheckServiceValidPath(HKEY hSubKey, TCHAR *pPath)
{
	DWORD	dwRet = 0x01;

	__try
	{
		TCHAR	szPath[512] = { 0 };
		TCHAR	szTemp[512] = { 0 };
		TCHAR	*pTemp = NULL;

		if (pPath[0] == '"')
			wcscpy_s(szTemp, 511, &pPath[1]);
		else
			wcscpy_s(szTemp, 511, pPath);

		_wcsupr_s(szTemp, 511);
		wcscpy_s(szPath, 511, szTemp);

		if (!wcschr(szTemp, '.'))
			return 0;

		pTemp = wcsstr(szTemp, TEXT("SYSTEM32\\"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT("SYSTEM32\\"));
			wsprintf(szPath, TEXT("%s\\%s"), szSystemDir, pTemp);
		}

		pTemp = wcsstr(szTemp, TEXT("%PROGRAMFILES%\\"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT("%PROGRAMFILES%\\"));
			wsprintf(szPath, TEXT("%s\\%s"), szProgramDir, pTemp);
		}
		if (m_bIsWow64)
		{
			pTemp = wcsstr(szTemp, TEXT("%PROGRAMFILES(X86)%\\"));
			if (pTemp)
			{
				pTemp += wcslen(TEXT("%PROGRAMFILES(X86)%\\"));
				wsprintf(szPath, TEXT("%s\\%s"), szProgramDirX86, pTemp);
			}
		}

		pTemp = wcsstr(szTemp, TEXT("%COMMONPROGRAMFILES%\\"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT("%COMMONPROGRAMFILES%\\"));
			wsprintf(szPath, TEXT("%s\\%s"), szCommProgram, pTemp);

			if (PathFileExists(szPath))
			{
				dwRet = 0x00;
				return dwRet;
			}

			//If OS is 64 bit, we need to check path in 32 also.
			//Modified by Vilas on 10 April 2015
			if (m_bIsx64)
			{
				wsprintf(szPath, TEXT("%s\\%s"), m_szCommProgramX86, pTemp);
				if (PathFileExists(szPath))
				{
					dwRet = 0x00;
					return dwRet;
				}
			}
		}

		pTemp = wcsstr(szTemp, TEXT("%SYSTEMROOT%\\"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT("%SYSTEMROOT%\\"));
			wsprintf(szPath, TEXT("%s\\%s"), szWindowsDir, pTemp);
		}

		pTemp = wcsstr(szTemp, TEXT("%ALLUSERSPROFILE%\\"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT("%ALLUSERSPROFILE%\\"));
			wsprintf(szPath, TEXT("%s\\%s"), szProgramData, pTemp);
		}

		pTemp = wcsstr(szTemp, TEXT("%PROGRAMDATA%\\"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT("%PROGRAMDATA%\\"));
			wsprintf(szPath, TEXT("%s\\%s"), szProgramData, pTemp);
		}

		pTemp = wcsstr(szTemp, TEXT("%USERPROFILE%\\"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT("%USERPROFILE%\\"));
			wsprintf(szPath, TEXT("%s\\%s"), szUserProfile, pTemp);
		}

		pTemp = wcsstr(szTemp, TEXT("%TEMP%\\"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT("%TEMP%\\"));
			wsprintf(szPath, TEXT("%s\\%s"), szTempLocal, pTemp);
		}

		pTemp = wcsstr(szTemp, TEXT("%PUBLIC%\\"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT("%PUBLIC%\\"));
			wsprintf(szPath, TEXT("%s\\%s"), szPublic, pTemp);
		}

		pTemp = wcsstr(szTemp, TEXT("%APPDATA%\\"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT("%APPDATA%\\"));
			wsprintf(szPath, TEXT("%s\\%s"), szAppData, pTemp);
		}

		pTemp = wcsstr(szTemp, TEXT("%WINDIR%\\"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT("%WINDIR%\\"));
			wsprintf(szPath, TEXT("%s\\%s"), szWindowsDir, pTemp);
		}

		if (_memicmp(pPath, TEXT("\\??\\"), wcslen(TEXT("\\??\\"))) == 0)
			wcscpy_s(szPath, 511, &szTemp[wcslen(TEXT("\\??\\"))]);


		pTemp = wcsstr(szPath, TEXT(".EXE"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT(".EXE"));
			*pTemp = '\0';
		}

		pTemp = wcsstr(szPath, TEXT(".SYS"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT(".SYS"));
			*pTemp = '\0';
		}

		pTemp = wcsstr(szPath, TEXT(".DLL"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT(".DLL"));
			*pTemp = '\0';
		}

		pTemp = wcsstr(szPath, TEXT(".OCX"));
		if (pTemp)
		{
			pTemp += wcslen(TEXT(".OCX"));
			*pTemp = '\0';
		}

		/*	if( m_bIsWow64 )
		Wow64DisableWow64FsRedirection( &OldValue ) ;
		*/
		if (PathFileExists(szPath))
			dwRet = 0x00;
		/*
		if( m_bIsWow64 )
		Wow64RevertWow64FsRedirection( OldValue ) ;
		*/

	}
	__except (CWardWizDumpCreater::CreateMiniDump(GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER)
	{
		AddLogEntry(L"### Exception in WardwizSrvMgmt_RegOpt::CheckServiceValidPath", 0, 0, true, SECONDLEVEL);
		return 0;
	}

	return dwRet;
}

/**********************************************************************************************************
*  Function Name  :	EnumRegValueNameDeletion
*  Description    :
*  Author Name    : Pradip
*  Date           : 1-Nov-2018
**********************************************************************************************************/
DWORD CCleanMalwareRegEntry::EnumRegValueNameDeletion(LPCTSTR pSubKey, TCHAR *pEntryName, HKEY hPredKey)
{

	DWORD	dwRet = 0x00;
	DWORD	dwValues = 0x00, dwType = 0x00, i;
	HKEY	hSubKey = NULL;

	TCHAR	szValueName[512], szValueData[512];
	DWORD	dwValueName, dwValueData;

	__try
	{

		if (RegOpenKeyEx(hPredKey, pSubKey, 0, KEY_ALL_ACCESS, &hSubKey) != ERROR_SUCCESS)
		{
			dwRet = 0x01;
			goto Cleanup;
		}

		bool	bRegInvalidFound = false;

		while (true)
		{
			bRegInvalidFound = false;
			dwValues = 0x00;
			RegQueryInfoKey(hSubKey, NULL, NULL, 0, NULL, NULL, NULL, &dwValues, NULL,
				NULL, NULL, NULL);
			if (dwValues == 0x00)
			{
				dwRet = 0x02;
				break;
			}

			for (i = 0; i<dwValues; i++)
			{
				memset(szValueName, 0x00, 512 * sizeof(TCHAR));
				memset(szValueData, 0x00, 512 * sizeof(TCHAR));

				dwValueName = dwValueData = 511;

				RegEnumValue(hSubKey, i, szValueName, &dwValueName, 0, &dwType,(LPBYTE)szValueData, &dwValueData);
				if (!szValueName[0])
					continue;

				dwRet = CheckServiceValidPath(hSubKey,szValueName);

				if (dwRet)
				{
				
					if (RegDeleteValue(hSubKey, szValueName) == ERROR_SUCCESS)
					{
						bRegInvalidFound = true;
						
					}
				}

				if (bRegInvalidFound)
					break;
			}

			if (!bRegInvalidFound)
				break;
		}
	}
	__except (CWardWizDumpCreater::CreateMiniDump(GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER)
	{
		dwRet = 0x10;
		AddLogEntry(L"### Exception in WardwizSrvMgmt_RegOpt::EnumRegValueNameDeletion", 0, 0, true, SECONDLEVEL);
	}

Cleanup:

	if (hSubKey)
		RegCloseKey(hSubKey);

	hSubKey = NULL;

	return dwRet;
}

/**********************************************************************************************************
*  Function Name  :	MyToUpper
*  Description    :input path convert to uppercase 
*  Author Name    : Pradip
*  Date           :31-10-2018
**********************************************************************************************************/
TCHAR* CCleanMalwareRegEntry:: MyToUpper(TCHAR *input)
{
	static TCHAR buffer[512] = { 0 };
	
	TCHAR *s = input;
	TCHAR *t = buffer;

	while (*s != '\0')
	{
		*t = toupper(*s);
		s++;
		t++;
	}
	
	return buffer;
}

/**********************************************************************************************************
*  Function Name  :	CleanMalwareRegEntry
*  Description    :
*  Author Name    : Pradip
*  Date           :31-10-2018
**********************************************************************************************************/
DWORD CCleanMalwareRegEntry::CleanMalwareRegEntry(LPCTSTR pszFilePath, bool &bStatus)
{
	DWORD dwRet = 0x00;
	DWORD dwSuccess = 0x00;
	
	_try
	{	
		//For current user entries
		dwSuccess = EnumRegValueDataForCurrentUsers(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Windows\\system32\\Serverx.exe"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\user\\AppData\\Roaming\\uTorrent\\uTorrent.exe"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\user\\AppData\\Local\\Temp\\{09a405f0-0a5f-4cfe-a424-a56e9a3186f}\\WinDefender.exe"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\user\\AppData\\Local\\Temp\\xelag.exe"));

		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\INTEL\\AppData\\Local\\Google\\Update\\1.3.33.17\\GoogleUpdateCore.exe"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Program Files\\Internet Download Manager\\IDMan.exe"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\INTEL\\AppData\\Local\\Temp\\xelag.exe")); 
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\INTEL\\AppData\\Local\\Google\\Update\\1.3.33.17\\GoogleUpdateCore.exe"));
		//Added on 02-11-2018
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\wel\\AppData\\Roaming\\Microsoft Office\\Microsoft Excel.WsF")); 
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\ADMINISTOR\\AppData\\Roaming\\kak4yclfqho\\eca4kf0t0of.exe")); 
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\ADMINISTOR\\AppData\\Roaming\\lj4hc2vv232\\4j4cmx2t5zk.exe")); 
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Program Files\\XWP2HPWN9K\\OS8QPVURW.exe")); 
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\ADMINISTOR\\AppData\\Roaming\\4rlhkiqwplq\\dkpwr1jg4tf.exe")); 
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\ADMINISTOR\\AppData\\Roaming\\jrjpjaafumf\\tiocfo2ckc1.exe"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\ADMINISTOR\\AppData\\Roaming\\dgb4qcad3u5\\lbmotwlhejv.exe"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\ADMINISTOR\\AppData\\Roaming\\i3alw210sjx\\4birt5yeijo.exe"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\ADMINISTOR\\AppData\\Roaming\\uwo1xbvhk01\\q3zlrj3dhod.exe"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\ADMINISTOR\\AppData\\Roaming\\wrp3j3q1h3v\\hgabp4vu0a4.exe"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\ADMINISTOR\\AppData\\Roaming\\qlcz2eqtdtr\\kziq4zshqfl.exe"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Program Files\\WQVENYHQDP\\WQVENYHQD.exe"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Program Files\\FUTFIGST6D\\FUTFIGST6.exe"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\ADMINISTOR\\AppData\\Roaming\\rw3xcl21esr\\oidkyfbvjcs.exe"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Program Files\\GKOK33A6PV\\0DJLB6CRJ.exe"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\WINDOWS\\M-5050402567620352053\\winmgr.exe"));


		//delete invalid subkey
		DeleteInvalidKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MountPoints2\\{8cf7302e-9f2c - 11e8 - b4af - 806d6172696f}\\Shell\\AutoRun\\command"));

		//For local_machine entries
		dwSuccess = EnumRegValueDataDeletion(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Program Files (x86)\\DriverPack Notifier\\DriverPackNotifier.exe"), HKEY_LOCAL_MACHINE);
		dwSuccess = EnumRegValueDataDeletion(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Program Files (x86)\\Microsoft Office\\Office12\\GrooveMonitor.exe"), HKEY_LOCAL_MACHINE);
		dwSuccess = EnumRegValueDataDeletion(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Program Files (x86)\\Epson Software\\Event Manager\\EEventManager.exe"), HKEY_LOCAL_MACHINE);
		dwSuccess = EnumRegValueDataDeletion(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\user\\AppData\\Local\\Temp\\xelag.exe"), HKEY_LOCAL_MACHINE);
		dwSuccess = EnumRegValueDataDeletion(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Program Files\\Realtek\\Audio\\HDA\\RtHDVCpl.exe"), HKEY_LOCAL_MACHINE);
		dwSuccess = EnumRegValueDataDeletion(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Program Files\\Winamp\\winampa.exe"), HKEY_LOCAL_MACHINE);
		dwSuccess = EnumRegValueDataDeletion(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Users\\INTEL\\AppData\\Local\\Temp\\xelag.exe"), HKEY_LOCAL_MACHINE);
		dwSuccess = EnumRegValueDataDeletion(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\Program Files\\win\\msn.exe"), HKEY_LOCAL_MACHINE);
		//Added on 2-11-2018
		dwSuccess = EnumRegValueDataDeletion(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("C:\\WINDOWS\\M-5050402567620352053\\winmgr.exe"), HKEY_LOCAL_MACHINE);


		//check for invalid explorer entries and delete within local 
		dwSuccess = EnumRegValueDataDeletion(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run", TEXT("C:\\PROGRA~3\\LOCALS~1\\Temp\\ccxovayun.exe"), HKEY_LOCAL_MACHINE);
		//For all invalid explorer entries within current user
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Wordpad\\Recent File List", TEXT("Explorer_Entries"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU", TEXT("Explorer_Entries"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell\\MuiCache", TEXT("Explorer_Entries"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\TypedPaths", TEXT("Explorer_Entries"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs", TEXT("Explorer_Entries"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist", TEXT("Explorer_Entries"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ComDlg32\\OpenSavePidlMRU", TEXT("Explorer_Entries"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ComDlg32\\LastVisitedPidlMRU", TEXT("Explorer_Entries"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Paint\\Recent File List", TEXT("Explorer_Entries"));
		dwSuccess = EnumRegValueDataForCurrentUsers(L"Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Regedit", TEXT("Explorer_Entries"));
					
		//Set REG_SZ value registry entries
		dwSuccess = SetRegSZValue(TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows"), TEXT("AppInit_DLLs"), TEXT(""), true, HKEY_LOCAL_MACHINE);
		dwSuccess = SetRegSZValue(TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), TEXT("Shell"), TEXT("explorer.exe"), true, HKEY_LOCAL_MACHINE);
		dwSuccess = SetRegSZValue(TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), TEXT("Userinit"), TEXT("C:\\Windows\\system32\\userinit.exe"), true, HKEY_LOCAL_MACHINE);
					
		//Set DWORD value registry entries
		dwSuccess = SetRegDWORDValue(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", L"DisableRegistryTools", 0x00, true, HKEY_LOCAL_MACHINE);
		dwSuccess = SetRegDWORDValue(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", L"DisableTaskMgr", 0x00, true, HKEY_LOCAL_MACHINE);

		//Check for  Shared dll entries within local
		dwSuccess = EnumRegValueNameDeletion(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDLLs", TEXT("SharedDLLs_Entries"), HKEY_LOCAL_MACHINE);
					
		//Check for invalid startup entries
		dwSuccess = EnumRegValueNameDeletion(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("Startup_Entries"), HKEY_LOCAL_MACHINE);
		dwSuccess = EnumRegValueNameDeletion(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce", TEXT("Startup_Entries"), HKEY_LOCAL_MACHINE);
		dwSuccess = EnumRegValueNameDeletion(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx", TEXT("Startup_Entries"), HKEY_LOCAL_MACHINE);
		dwSuccess = EnumRegValueDataForCurrentUsers(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", TEXT("Startup_Entries"));

		//Will require in future if there is malware path
		/*TCHAR *szFilePath = (TCHAR*)((LPCTSTR)pszFilePath);
		szFilePathName = MyToUpper(szFilePath);

		if (szFilePathName[0])
		{
			dwSuccess = EnumRegValueDataForCurrentUsers(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", szFilePathName);
			dwSuccess = EnumRegValueDataDeletion(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", szFilePathName, HKEY_LOCAL_MACHINE);
			dwSuccess = EnumRegValueDataDeletion(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run", szFilePathName, HKEY_LOCAL_MACHINE);
			dwSuccess = EnumRegValueDataDeletion(L"SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run", szFilePathName, HKEY_LOCAL_MACHINE);

			if (!dwSuccess)
				bStatus = true;
			goto Cleanup;
		}
		*/

		goto Cleanup;
	}
	__except (CWardWizDumpCreater::CreateMiniDump(GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER)
	{
		 dwRet= 0x01;
		AddLogEntry(L"### Exception in CCleanMalwareRegEntry::CleanMalwareRegEntry", 0, 0, true, SECONDLEVEL);
	}

Cleanup:

	return dwRet;	
}
